A CATEDRAL E O BAZAR(The Cathedral and the Bazaar)por Eric S. RaymondCópia e redistribuição permitida sem royalty contanto que esta notificação esteja preservada.Traduzido por Erik Kohler - ekohler at programmer.netData: 1998/11/12 04:01:20Eu analiso um projeto bem sucedido de código livre, o Fetchmail, que foi executado como umteste   deliberado   de   algumas   teorias   surpreendentes   sobre   a   tecnologia   de   programaçãosugerida   pela   história   do   Linux.   Eu   discuto   estas   teorias   nos   termos   de   dois   estilosfundamentais diferentes de desenvolvimento, o modelo "catedral'' da maior parte do mundocomercial contra o modelo "bazar'' do mundo do Linux. Eu mostro que estes modelos derivamde suposições opostas sobre a natureza da tarefa de depurar o software. Eu faço então umargumento sustentado na experiência do Linux para a proposição que "Dados bastante olhos,todos os erros são triviais'', sugiro analogias produtivas com outros sistemas auto-corrigíveisde agentes egoístas, e concluo com alguma exploração das implicações desta introspeçãopara o futuro do software.1. A Catedral e o Bazar Linux é subversivo.Quem pensaria mesmo há cinco anos atrás que um sistema operacional de classe mundialpoderia surgir como que por mágica pelo tempo livre de milhares de colaboradores espalhadospor todo o planeta, conectado somente pelos tênues cordões da Internet? Certamente não eu.No tempo que o Linux apareceu em minha tela-radar no início de 1993, eu já tinha meenvolvido no desenvolvimento de Unix e de código aberto por dez anos. Eu fui um dosprimeiros contribuintes para o projeto GNU nos meados de 1980. Eu tinha liberado bastante dosoftware livre na rede, desenvolvendo ou co-desenvolvendo diversos programas (nethack,Emacs em modo VC e GUD, xlife, e outros) que estão ainda em largo uso hoje. Eu pensei queeu sabia como isso era feito. Linux ultrapassou muito o que eu pensei que sabia. Eu estavapregando   o   modo   Unix   de   uso   de   pequenas   ferramentas,   de   prototipagem   rápida   e   deprogramação   evolucionária   por   anos.   Mas   eu   acreditei   também   que   havia   algumacomplexidade crítica, acima da qual uma aproximação mais centralizada, mais a priori erarequerida.   Eu   acreditava   que   os   softwares   mais   importantes   (sistemas   operacionais   eferramentas   realmente   grandes   como  Emacs)   necessitavam   ser   construídos   como  ascatedrais,   habilmente   criados   com   cuidado   por   mágicos   ou   pequenos   grupos   de   magostrabalhando em esplêndido isolamento, com nenhum beta para ser liberado antes de seutempo.   O   estilo   de   Linus   Torvalds   de   desenvolvimento   --   libere   cedo   e   freqüentemente,delegue tudo que você possa, esteja aberto ao ponto da promiscuidade -- veio como umasurpresa. Nenhuma catedral calma e respeitosa aqui -- ao invés, a comunidade Linux pareceuassemelhar-se   a   um   grande   e   barulhento   bazar   de   diferentes   agendas   e   aproximações(adequadamente   simbolizada   pelos   repositórios   do   Linux,   que   aceitaria   submissões   dequalquer pessoa) de onde um sistema coerente e estável poderia aparentemente emergirsomente por uma sucessão de milagres. O fato de que este estilo bazar pareceu funcionar, efuncionar bem, veio como um distinto choque. Conforme eu aprendia ao meu redor, trabalheiduramente não apenas em projetos individuais, mas também tentando compreender porque omundo do Linux não somente não se dividiu em confusão mas parecia aumentar a sua força auma velocidade quase inacreditável para os construtores de catedrais. Em meados de 1996 eupensei que eu estava começando a compreender. O acaso deu-me uma maneira perfeita paratestar minha teoria, na forma de um projeto de código aberto que eu poderia conscientementetentar executar no estilo bazar. Assim eu fiz -- e foi um sucesso significativo. No resto desteartigo eu contarei a história desse projeto, e eu irei usá-la para propor alguns aforismos sobreo desenvolvimento eficaz de código aberto. Nem tudo eu aprendi primeiramente no mundo do
Linux, mas nós veremos como o mundo do Linux lhe dá um ponto particular. Se eu estivercorreto, eles o ajudarão a compreender exatamente o que é que faz a comunidade do Linuxser uma fonte de software bom -- e ajuda a você a se tornar mais produtivo. 2. O correio deve ser entregue desde 1993 Eu venho cuidando da parte técnica de um pequeno Provedor de Acesso Internet de acessogratuito chamado Chester County InterLink (CCIL) em West Chester, Pensilvânia (eu fui co-fundador do CCIL e escrevi nosso software multiusuário de BBS -- você pode observá-loexecutando  um  telnet   para  locke.ccil.org.  Hoje  suporta   quase   três   mil   usuários  em  trintalinhas.) O trabalho permitiu-me o acesso 24 horas por dia à rede através da linha de 56K doCCIL -- de fato,  praticamente exigiu! Consequentemente, eu fiquei acostumado a acessoinstantâneo ao correio Internet. Por razões complicadas, era difícil fazer o SLIP funcionar entreminha máquina de casa (snark.thyrsus.com) e o CCIL. Quando eu finalmente consegui, euachei incômodo ter que executar telnet periodicamente para o locke para verificar meu correio.O que eu queria era que ele fosse enviado para o snark de modo que eu fosse notificadoquando   uma   mensagem   chegasse   e   pudesse   manuseá-lo   usando   todas   as   minhasferramentas locais. O simples reenvio do sendmail não funcionaria, porque minha máquinalocal não está sempre na rede e não tem um IP estático. O que eu precisava era um programaque pegasse meu correio através da conexão SLIP e o entregasse localmente. Eu sabia quetais programas existiam, e que a maioria deles usava um protocolo de aplicação simpleschamado POP (Post Office Protocol). E, realmente, já havia um servidor POP3 incluído comsistema operacional BSD/OS do locke. Eu precisava de um cliente POP3. Então eu procurei naInternet e encontrei um. Na verdade, eu encontrei três ou quatro. Eu usei o pop-perl por algumtempo,   mas   faltava   o   que   parecia   uma   característica   óbvia,   a   habilidade   de   alterar   osendereços   no   correio   recebido   para   que   as   respostas   fossem   enviadas   corretamente.   Oproblema era este: suponha que alguém chamado `joe' no locke tenha me enviado umamensagem. Se eu capturasse o correio para o snark e tentasse então lhe responder, meuprograma de correio tentaria alegremente enviá-lo a um `joe' inexistente no snark. Editarmanualmente os endereços de resposta para adicionar '@ccil.org' rapidamente tornou-se umtormento. Isto era claramente algo que o computador teria que fazer para mim. Mas nenhumdos clientes POP existentes sabiam como! E isto nos traz à primeira lição:  1. Todo bomtrabalho de software começa colocando o dedo na ferida de um programador. Talvez istodeveria ter sido óbvio (um antigo provérbio diz que "necessidade é a mãe da invenção'') masmuitas vezes os programadores gastam seus dias buscando retorno em programas que elesnão necessitam nem gostam. Mas não no mundo do Linux -- o que pode explicar porque aqualidade média do software originada na comunidade de Linux é tão alta. Assim, eu me lanceiimediatamente   com   o  ímpeto   de   codificar   um   novo   cliente   POP3  para   competir   com  osexistentes? De maneira alguma! Eu olhei com cuidado os utilitários POP que eu tinha àdisposição, perguntando-me "qual deles é o mais próximo do que eu quero?''. Porque... 2. Osprogramadores bons sabem o que escrever. O grandes sabem o que re-escrever (e re-usar).  Embora eu não me considere um grande programador, eu tento me passar por um.Uma importante característica dos grandes é a preguiça construtiva. Eles sabem que vocêganha um 'A' não por esforço, mas por resultados, e é quase sempre mais fácil partir de umaboa  solução   parcial   do  que   do  nada.  não   tentou   realmente   escrever   Linux   do  nada.  Aocontrário, ele começou re-usando código e idéias do Minix, um pequeno sistema operacionalUnix-like para máquinas 386. Eventualmente todo o código Minix se foi ou não completamenterescrito -- mas quando estava lá, forneceu as bases para o infante que se transformaria noLinux. Com o mesmo pensamento, eu fui procurar um utilitário POP que fosse razoavelmentebem codificado, para usar como uma base de desenvolvimento. A tradição do mundo Unix decompartilhar o código fonte foi sempre amigável para a reutilização de código (esta é a razãoporque o projeto de GNU escolheu o Unix como sistema operacional base, apesar das sériasreservas   sobre   o  mesmo).   O  mundo   Linux   tem   levado   esta  tradição   quase   a  seu   limitetecnológico; tem terabytes de códigos abertos amplamente disponíveis. Assim gastando tempoprocurando algum software quase-bom-o-bastante feito por alguém é mais provável dar a vocêmais bons resultados no mundo Linux do que em qualquer outro lugar. Algumas semanasmais tarde, entretanto, eu tropecei pelo código do 'popclient' desenvolvido por Carl Harris, edescobri que eu tinha um problema. Embora o fetchpop tenha tido algumas idéias boas e
originais (tal como o modo daemon), podia somente trabalhar com POP3 e foi codificado deuma   maneira   um   tanto   amadora   (Seung-Hong   era   um   programador   brilhante   poréminexperiente, e ambas as características ficaram evidentes). O código de Carl era melhor,bastante   profissional   e   sólido,   mas   em   seu   programa   faltou   diversas   característicasimportantes e complicadas de serem implementadas do fetchpop (incluindo aquelas que euimplementei). Ficar ou trocar? Se eu trocasse, eu estaria jogando fora o código que eu já haviafeito em troca de uma base melhor do desenvolvimento. Um motivo prático para trocar era apresença de suporte para vários protocolos. POP3 é o protocolo mais comumente utilizado detodos   os   protocolos   de   correio   dos  servidores,   mas   não   o   único.  Fetchpop   e   os   outrosconcorrentes   não   faziam   POP2,   RPOP   ou   APOP,   e   eu   estava   realmente   tendo   algunspensamentos de talvez adicionar ou Protocolo de Acesso a Mensagem da Internet, o maisrecente e poderoso protocolo de correio desenvolvido) só para me divertir. Mas eu tinha umarazão mais teórica para pensar que trocar seria uma boa idéia, alguma coisa que eu aprendimuito antes do Linux. 3. "Planeje jogar algo fora; você irá, de qualquer maneira.'' (FredBrooks, "The Mythical Man-Month'', Capítulo 11)  Ou,   colocando   de   outra   forma,   vocêfreqüentemente não entende realmente o problema até depois da primeira vez que vocêimplementa   uma   solução.   Na   segunda   vez,   talvez   você   saiba   o   suficiente   para   fazercorretamente.   Então  se você quer   fazer  algo  certo,   esteja preparado  para começar  tudonovamente pelo menos uma vez. Bem (eu disse para mim mesmo) as mudanças no fetchpopforam a minha primeira tentativa. Então eu troquei. Depois que eu mandei meu primeiroconjunto de alterações para Carl Harris em 25 de junho de 1996, eu percebi que na verdadeele perdera o interesse pelo popclient há algum tempo até então. O código era um poucoempoeirado, com pequenos erros. Eu tinha muitas mudanças para fazer, e nós rapidamenteconcordamos que o lógico para eu fazer era tomar conta do programa. Sem perceber, oprojeto havia se intensificado. Eu não estava mais contemplando somente pequenos consertospara um cliente POP existente. Eu estava mantendo um cliente completo, e havia idéiasborbulhando   na   minha   cabeça   que   eu   sabia   iriam   provavelmente   levar   a   importantesmudanças. Em uma cultura de software que encoraja a troca de código, isto é um caminhonatural para um projeto evoluir. Eu estava representando isto: 4. Se você tem a atitude certa,problemas interessantes irão encontrá-lo.  Mas a atitude do Carl  Harris foi  ainda maisimportante. Ele entendeu que  5. Quando você perde interesse em um programa, suaúltima obrigação a fazer com ele é entregá-lo a um sucessor competente. Sem ao menoster que discutir isso, Carl e eu sabíamos que nós tínhamos um objetivo em comum de ter amelhor solução disponível. A única questão para nós foi se eu poderia me estabelecer comoum par de mãos seguras para isso. Uma vez que eu tenha feito isso, ele agiu com cortesia erapidez. Eu espero que eu aja assim quando chegar a minha vez. 3. A importância de ter usuários E então eu herdei o popclient. Tão importante quanto, eu herdei os usuários do popclient.Usuários são ótimas coisas para se ter, e não somente porque eles demonstram que você estásatisfazendo uma necessidade, que você fez algo certo. Cultivados de maneira adequada, elespodem se tornar co-desenvolvedores. Outra força da tradição do Unix, uma que o Linux temlevado a um alegre extremo, é que muitos usuários são desenvolvedores também. E porque ocódigo   fonte   está   disponível,   eles   podem   ser   desenvolvedores   eficazes.   Isto   pode   sertremendamente útil para reduzir o tempo de depuração. Com um pouco de estímulo, seususuários irão diagnosticar problemas, sugerir correções e ajudar a melhorar o código muitomais rapidamente do que você poderia fazer sem ajuda. 6. Tratar seus usuários como co-desenvolvedores é seu caminho mais fácil para uma melhora do código e depuraçãoeficaz. O poder deste efeito é fácil de se subestimar. De fato, todos nós do mundo do códigoaberto   subestimamos   drasticamente   como  isto   iria   incrementar   o   número   de   usuários   ediminuir a complexidade do sistema, até que Linus Torvalds nos mostrou de outra forma. Defato, eu penso que a engenhosidade do Linus e a maior parte do que desenvolveu não foram aconstrução do kernel do Linux em si, mas sim a sua invenção do modelo de desenvolvimentodo   Linux.   Quando   eu   expressei   esta   opinião   na   sua   presença   uma   vez,   ele   sorriu   ecalmamente   repetiu   algo   que   freqüentemente   diz:   "Sou   basicamente   uma   pessoa   muitopreguiçosa que gosta de ganhar crédito por coisas que outras pessoas realmente fazem.''Prequiçoso como uma raposa. Ou, como Robert Heinlein teria dito, muito preguiçoso para
falhar. Em retrospecto, um precedente para o sucesso e métodos do Linux pode ser observadono desenvolvimento da biblioteca do GNU Emacs Lisp e os repositórios de código Lisp. Emcontraste com o estilo de desenvolvimento catedral do núcleo do Emacs C e a maioria dasoutras ferramentas da FSF, a evolução do grupo de código Lisp foi fluída e bastante dirigida aousuário. Idéias e protótipos foram freqüentemente re-escritos três ou quatro vezes antes deatingirem uma forma estável final. E colaborações permitidas pela Internet, a la Linux, foramfreqüentes.   Realmente,   minha   mais   bem   sucedida   codificação   anterior   ao   fetchmail   foiprovavelmente o modo Emacs VC, uma colaboração do tipo do Linux por email com trêsoutras pessoas, somente uma das eu conheci pessoalmente até hoje. Foi um front-end paraSCCS, RCS e posteriormente CVS pelo Emacs que oferecia operações de controle de versão"um toque''. Evoluiu de um pequeno e grosseiro modo sccs.el que alguém havia escrito. E odesenvolvimento do VC foi bem sucedido porque, ao contrário do próprio Emacs, o código doEmacs Lisp poderia ir por gerações de lançamento/teste/aperfeiçoamento muito rapidamente. 4. Libere cedo, libere freqüentementeLiberações novas e freqüentes são uma parte crítica do modelo de desenvolvimento do Linux.A maioria dos desenvolvedores (incluindo eu) costumava acreditar que esta era uma mápolítica para projetos maiores que os triviais, porque versões novas são quase por definiçãocheias de erros e você não quer acabar com a paciência dos seus usuários. Esta crençareforçou o compromisso de todos com o estilo de desenvolvimento catedral. Se o principalobjetivo  era  o de  usuários   verem  menos   erros   quanto   possível,   por que  então  você  iriasomente lançar um em cada seis meses (ou freqüentemente menos), e trabalhar como umcachorro depurando entre as liberações. O núcleo do Emacs C foi desenvolvido desta forma. Abiblioteca Lisp, de fato, não foi -- porque havia repositórios Lisp ativos fora do controle da FSF,aonde você poderia ir para achar versões novas e em desenvolvimento, independentementedo ciclo de liberação do Emacs. A mais importante destas, o repositório elisp do Estado deOhio, antecipou o espírito e muitas das características dos atuais grandes repositório de Linux.Mas pouco de nós realmente pensou muito sobre o que estávamos fazendo, ou sobre o que aexistência deste repositório sugeriu sobre problemas no modelo de desenvolvimento catedralda FSF.  Eu  fiz uma séria tentativa por volta de 1992 para ter  bastante código  de Ohioformalmente fundido na biblioteca oficial do Emacs Lisp. Encontrei problemas políticos e fuimuito mal sucedido. Mas um ano depois, visto que o Linux se tornou amplamente conhecido,ficou claro que alguma coisa diferente e muito saudável estava acontecendo. A política dedesenvolvimento aberta do Linus era exatamente o oposto do modelo de desenvolvimentocatedral. Os repositórios sunsite e tsx-11 estavam germinando, múltiplas distribuições estavamsurgindo. E tudo isto foi guiado por uma freqüência desconhecida de liberações de núcleo desistemas. Linus estava tratando seus usuários como co-desenvolvedores na maneira maiseficaz possível: 7. Liberece cedo. Libere freqüentemente. E ouça seus fregueses. Isso nãoera muito a inovação do Linus (algo como isso estava sendo a tradição do mundo Unix por umlongo tempo), mas em elevar isto até um grau de intensidade que alcançava a complexidadedo que ele estava desenvolvendo. Nestes primórdios tempos (por volta de 1991) não eraestranho para ele liberar um novo kernel mais de uma vez por dia! E, porque ele cultivava suabase de co-desenvolvedores e incitava fortemente a Internet por colaboração como nenhumoutro, isto funcionou. Mas como isto funcionou? E era isto algo que eu poderia duplicar, ou eraalgo   que   dependia   da   genialidade   única  de   Linus   Torvalds?   Eu   não   pensei   assim.Reconhecidamente, Linus é um excelente desenvolvedor (quantos de nós poderia planejar umkernel completo de um sistema operacional de qualidade de produção?). Mas o Linux nãorepresentou nenhum salto conceitual impressionante a frente. Linus não é (ou pelo menos,ainda não) um gênio inovativo de projeto do estilo que, por exemplo, Richard Stallman ouJames Gosling (do NeWS e Java) são. Ao contrário, para mim Linus parece ser um gênio daengenharia, com um sexto sentido em evitar erros e desenvolvimentos que levem a um becosem saída e uma verdadeira habilidade para achar o caminho do menor esforço do ponto A aoponto B.  De fato,  todo o projeto do Linux  exala esta qualidade e  espelha a  abordagemconservadora   e   simplificada   de   planejamento   do   Linus.   Então,   se   liberações   rápidas   einfluenciar a Internet a todo custo não foram acidentes mas partes integrantes da perspicáciado   gênio   de   engenharia   do   Linus   para   o   caminho  do   menor   esforço,   o   que   ele   estavaenfatizando? O que ele estava maquinando? Posto desta forma, a questão responde a si
mesma. Linus estava mantendo seus usuários/desenvolvedores constantemente estimuladose   recompensados   --   estimulados   pela   perspectiva   de   estar   tendo   um   pouco   de   açãosatisfatória do ego, recompensados pela visão do constante (até mesmo diário) melhoramentodo seu trabalho. Linus estava diretamente direcionado a maximizar o número de pessoas-horadedicadas a depuração e ao desenvolvimento, mesmo com o possível custo da instabilidadeno código e extinção da base de usuários se qualquer erro sério provasse ser intratável. Linusestava se comportando como se acreditasse em algo como isto: 8. Dada uma base grande osuficiente   de   beta-testers   e   co-desenvolvedores,   praticamente   todo   problema   serácaracterizado rapidamente e a solução será óbvia para alguém. Ou, menos formalmente,"Dados olhos suficientes, todos os erros são triviais.'' Eu chamo isso de: "Lei de Linus''. Minhaformulação original foi que todo problema "será transparente para alguém''. Linus objetou quea   pessoa   que   entende   e   conserta   o   problema   não   é   necessariamente   ou   mesmofreqüentemente a pessoa que primeiro o caracterizou. "Alguém acha o problema,'' ele diz, "euma outra pessoa o entende. E eu deixo registrado que achar isto é o grande desafio.'' Mas oponto é que ambas as coisas tendem a acontecer rapidamente. Aqui, eu penso, é o centro dadiferença fundamental entre os estilos bazar e catedral. Na visão catedral de programação,erros e problemas de desenvolvimento são difíceis, insidiosos, um fenômeno profundo. Levameses de exame minucioso por poucas pessoas dedicadas para desenvolver confiança de quevocê se livrou de todos eles. Por conseguinte os longos intervalos de liberação, e o inevitáveldesapontamento quando as liberações por tanto tempo esperadas não são perfeitas. Na visãobazar, por outro lado, você assume que erros são geralmente um fenômeno trivial -- ou, pelomenos, eles se tornam triviais muito rapidamente quando expostos para centenas de ávidosco-desenvolvedores   triturando   cada   nova   liberação.   Consequentemente   você   liberafreqüentemente para ter mais correções, e como um benéfico efeito colateral você tem menosa perder se um erro ocasional aparece. E é isto. É o suficiente. Se a "Lei de Linus'' é falsa,então qualquer sistema tão complexo como o kernel do Linux, sendo programado por tantasmãos quantas programam o kernel do Linux, deveria a um certo ponto tido um colapso sob opeso de interações imprevisíveis e erros "profundos'' não descobertos. Se isto é verdade, poroutro lado, é suficiente para explicar a relativa falta de erros do Linux. E talvez isso não deveriaser uma surpresa, mesmo assim. Anos atrás, sociologistas descobriram que a opinião médiade uma massa de observadores especialistas (ou igualmente ignorantes) é um indicador maisseguro que o de um único observador escolhido aleatoriamente. Eles chamaram isso de o"efeito Delphi''. Parece que o que o Linus tem mostrado é que isto se aplica até mesmo paradepurar um sistema operacional -- que o efeito Delphi pode suavizar a complexidade dodesenvolvimento até mesmo em nível de complexidade do kernel de um sistema operacional.Eu sou grato a Jeff Dutky por apontar que a lei de Linus pode ser refeita como "Depurar éparalelizável''. Jeff observa que embora depurar requer que depuradores se comuniquem comalgum desenvolvedor coordenador, não requer coordenação significante entre depuradores.Assim não cai vítima para a mesma complexidade quadrática e custos de gerência que faz serproblemático adicionar desenvolvedores. Na prática, a perda teórica de eficiência devido aduplicação de trabalho por depuradores quase nunca parece ser um problema no mundo doLinux.  Um efeito da  ``política  libere cedo e freqüentemente''  é minimizar esta duplicaçãopropagando   consertos   rapidamente.   Brooks   até   mesmo   fez   uma   observação   improvisadarelacionada à observação de Jeff: "O custo total de manter um programa amplamente utilizadoé tipicamente 40 porcento ou mais o custo de desenvolvê-lo. Surpreendentemente este custo émuito afetado pelo número de usuários. Mais usuários acham mais erros.'' (minha ênfase).Mais usuários acham  mais erros porque  adicionar mais  usuários adiciona mais maneirasdiferentes   de   testar   o   programa.   Este   efeito   é   amplificado   quando   os   usuários   são   co-desenvolvedores.   Cada   um   aborda   a  tarefa   de  caracterização   de  erro   com  um   conjuntoperceptivo ligeiramente diferente e ferramenta analítica, um ângulo diferente do problema. O"efeito   Delphi''   parece   funcionar   precisamente   por   causa   desta   variação.   No   contextoespecífico da depuração, a variação também tende a reduzir o feito da duplicação. Entãoadicionar mais beta-testers pode não reduzir a complexidade de um erro "profundo'' correntedo ponto  de  vista do desenvolvedor,  mas aumenta a  probabilidade  que a ferramenta dealguém irá de encontro ao problema de uma maneira tal que o problema será trivial para estapessoa. Linus cobre suas apostas. Caso haja erros sérios, as versões do kernel do Linux sãonumeradas de forma que usuários em potencial podem fazer a escolha de executar a últimaversão   designada   "estável''   ou   correr   o   risco   de   encontrar   erros   para   obter   novascaracterísticas.   Esta   técnica  não   é   ainda   formalmente   imitada   pela   maioria   dos
Linux, mas nós veremos como o mundo do Linux lhe dá um ponto particular. Se eu estivercorreto, eles o ajudarão a compreender exatamente o que é que faz a comunidade do Linuxser uma fonte de software bom -- e ajuda a você a se tornar mais produtivo. 2. O correio deve ser entregue desde 1993 Eu venho cuidando da parte técnica de um pequeno Provedor de Acesso Internet de acessogratuito chamado Chester County InterLink (CCIL) em West Chester, Pensilvânia (eu fui co-fundador do CCIL e escrevi nosso software multiusuário de BBS -- você pode observá-loexecutando  um  telnet   para  locke.ccil.org.  Hoje  suporta   quase   três   mil   usuários  em  trintalinhas.) O trabalho permitiu-me o acesso 24 horas por dia à rede através da linha de 56K doCCIL -- de fato,  praticamente exigiu! Consequentemente, eu fiquei acostumado a acessoinstantâneo ao correio Internet. Por razões complicadas, era difícil fazer o SLIP funcionar entreminha máquina de casa (snark.thyrsus.com) e o CCIL. Quando eu finalmente consegui, euachei incômodo ter que executar telnet periodicamente para o locke para verificar meu correio.O que eu queria era que ele fosse enviado para o snark de modo que eu fosse notificadoquando   uma   mensagem   chegasse   e   pudesse   manuseá-lo   usando   todas   as   minhasferramentas locais. O simples reenvio do sendmail não funcionaria, porque minha máquinalocal não está sempre na rede e não tem um IP estático. O que eu precisava era um programaque pegasse meu correio através da conexão SLIP e o entregasse localmente. Eu sabia quetais programas existiam, e que a maioria deles usava um protocolo de aplicação simpleschamado POP (Post Office Protocol). E, realmente, já havia um servidor POP3 incluído comsistema operacional BSD/OS do locke. Eu precisava de um cliente POP3. Então eu procurei naInternet e encontrei um. Na verdade, eu encontrei três ou quatro. Eu usei o pop-perl por algumtempo,   mas   faltava   o   que   parecia   uma   característica   óbvia,   a   habilidade   de   alterar   osendereços   no   correio   recebido   para   que   as   respostas   fossem   enviadas   corretamente.   Oproblema era este: suponha que alguém chamado `joe' no locke tenha me enviado umamensagem. Se eu capturasse o correio para o snark e tentasse então lhe responder, meuprograma de correio tentaria alegremente enviá-lo a um `joe' inexistente no snark. Editarmanualmente os endereços de resposta para adicionar '@ccil.org' rapidamente tornou-se umtormento. Isto era claramente algo que o computador teria que fazer para mim. Mas nenhumdos clientes POP existentes sabiam como! E isto nos traz à primeira lição:  1. Todo bomtrabalho de software começa colocando o dedo na ferida de um programador. Talvez istodeveria ter sido óbvio (um antigo provérbio diz que "necessidade é a mãe da invenção'') masmuitas vezes os programadores gastam seus dias buscando retorno em programas que elesnão necessitam nem gostam. Mas não no mundo do Linux -- o que pode explicar porque aqualidade média do software originada na comunidade de Linux é tão alta. Assim, eu me lanceiimediatamente   com   o  ímpeto   de   codificar   um   novo   cliente   POP3  para   competir   com  osexistentes? De maneira alguma! Eu olhei com cuidado os utilitários POP que eu tinha àdisposição, perguntando-me "qual deles é o mais próximo do que eu quero?''. Porque... 2. Osprogramadores bons sabem o que escrever. O grandes sabem o que re-escrever (e re-usar).  Embora eu não me considere um grande programador, eu tento me passar por um.Uma importante característica dos grandes é a preguiça construtiva. Eles sabem que vocêganha um 'A' não por esforço, mas por resultados, e é quase sempre mais fácil partir de umaboa  solução   parcial   do  que   do  nada.  não   tentou   realmente   escrever   Linux   do  nada.  Aocontrário, ele começou re-usando código e idéias do Minix, um pequeno sistema operacionalUnix-like para máquinas 386. Eventualmente todo o código Minix se foi ou não completamenterescrito -- mas quando estava lá, forneceu as bases para o infante que se transformaria noLinux. Com o mesmo pensamento, eu fui procurar um utilitário POP que fosse razoavelmentebem codificado, para usar como uma base de desenvolvimento. A tradição do mundo Unix decompartilhar o código fonte foi sempre amigável para a reutilização de código (esta é a razãoporque o projeto de GNU escolheu o Unix como sistema operacional base, apesar das sériasreservas   sobre   o  mesmo).   O  mundo   Linux   tem   levado   esta  tradição   quase   a  seu   limitetecnológico; tem terabytes de códigos abertos amplamente disponíveis. Assim gastando tempoprocurando algum software quase-bom-o-bastante feito por alguém é mais provável dar a vocêmais bons resultados no mundo Linux do que em qualquer outro lugar. Algumas semanasmais tarde, entretanto, eu tropecei pelo código do 'popclient' desenvolvido por Carl Harris, edescobri que eu tinha um problema. Embora o fetchpop tenha tido algumas idéias boas e
originais (tal como o modo daemon), podia somente trabalhar com POP3 e foi codificado deuma   maneira   um   tanto   amadora   (Seung-Hong   era   um   programador   brilhante   poréminexperiente, e ambas as características ficaram evidentes). O código de Carl era melhor,bastante   profissional   e   sólido,   mas   em   seu   programa   faltou   diversas   característicasimportantes e complicadas de serem implementadas do fetchpop (incluindo aquelas que euimplementei). Ficar ou trocar? Se eu trocasse, eu estaria jogando fora o código que eu já haviafeito em troca de uma base melhor do desenvolvimento. Um motivo prático para trocar era apresença de suporte para vários protocolos. POP3 é o protocolo mais comumente utilizado detodos   os   protocolos   de   correio   dos  servidores,   mas   não   o   único.  Fetchpop   e   os   outrosconcorrentes   não   faziam   POP2,   RPOP   ou   APOP,   e   eu   estava   realmente   tendo   algunspensamentos de talvez adicionar ou Protocolo de Acesso a Mensagem da Internet, o maisrecente e poderoso protocolo de correio desenvolvido) só para me divertir. Mas eu tinha umarazão mais teórica para pensar que trocar seria uma boa idéia, alguma coisa que eu aprendimuito antes do Linux. 3. "Planeje jogar algo fora; você irá, de qualquer maneira.'' (FredBrooks, "The Mythical Man-Month'', Capítulo 11)  Ou,   colocando   de   outra   forma,   vocêfreqüentemente não entende realmente o problema até depois da primeira vez que vocêimplementa   uma   solução.   Na   segunda   vez,   talvez   você   saiba   o   suficiente   para   fazercorretamente.   Então  se você quer   fazer  algo  certo,   esteja preparado  para começar  tudonovamente pelo menos uma vez. Bem (eu disse para mim mesmo) as mudanças no fetchpopforam a minha primeira tentativa. Então eu troquei. Depois que eu mandei meu primeiroconjunto de alterações para Carl Harris em 25 de junho de 1996, eu percebi que na verdadeele perdera o interesse pelo popclient há algum tempo até então. O código era um poucoempoeirado, com pequenos erros. Eu tinha muitas mudanças para fazer, e nós rapidamenteconcordamos que o lógico para eu fazer era tomar conta do programa. Sem perceber, oprojeto havia se intensificado. Eu não estava mais contemplando somente pequenos consertospara um cliente POP existente. Eu estava mantendo um cliente completo, e havia idéiasborbulhando   na   minha   cabeça   que   eu   sabia   iriam   provavelmente   levar   a   importantesmudanças. Em uma cultura de software que encoraja a troca de código, isto é um caminhonatural para um projeto evoluir. Eu estava representando isto: 4. Se você tem a atitude certa,problemas interessantes irão encontrá-lo.  Mas a atitude do Carl  Harris foi  ainda maisimportante. Ele entendeu que  5. Quando você perde interesse em um programa, suaúltima obrigação a fazer com ele é entregá-lo a um sucessor competente. Sem ao menoster que discutir isso, Carl e eu sabíamos que nós tínhamos um objetivo em comum de ter amelhor solução disponível. A única questão para nós foi se eu poderia me estabelecer comoum par de mãos seguras para isso. Uma vez que eu tenha feito isso, ele agiu com cortesia erapidez. Eu espero que eu aja assim quando chegar a minha vez. 3. A importância de ter usuários E então eu herdei o popclient. Tão importante quanto, eu herdei os usuários do popclient.Usuários são ótimas coisas para se ter, e não somente porque eles demonstram que você estásatisfazendo uma necessidade, que você fez algo certo. Cultivados de maneira adequada, elespodem se tornar co-desenvolvedores. Outra força da tradição do Unix, uma que o Linux temlevado a um alegre extremo, é que muitos usuários são desenvolvedores também. E porque ocódigo   fonte   está   disponível,   eles   podem   ser   desenvolvedores   eficazes.   Isto   pode   sertremendamente útil para reduzir o tempo de depuração. Com um pouco de estímulo, seususuários irão diagnosticar problemas, sugerir correções e ajudar a melhorar o código muitomais rapidamente do que você poderia fazer sem ajuda. 6. Tratar seus usuários como co-desenvolvedores é seu caminho mais fácil para uma melhora do código e depuraçãoeficaz. O poder deste efeito é fácil de se subestimar. De fato, todos nós do mundo do códigoaberto   subestimamos   drasticamente   como  isto   iria   incrementar   o   número   de   usuários   ediminuir a complexidade do sistema, até que Linus Torvalds nos mostrou de outra forma. Defato, eu penso que a engenhosidade do Linus e a maior parte do que desenvolveu não foram aconstrução do kernel do Linux em si, mas sim a sua invenção do modelo de desenvolvimentodo   Linux.   Quando   eu   expressei   esta   opinião   na   sua   presença   uma   vez,   ele   sorriu   ecalmamente   repetiu   algo   que   freqüentemente   diz:   "Sou   basicamente   uma   pessoa   muitopreguiçosa que gosta de ganhar crédito por coisas que outras pessoas realmente fazem.''Prequiçoso como uma raposa. Ou, como Robert Heinlein teria dito, muito preguiçoso para
falhar. Em retrospecto, um precedente para o sucesso e métodos do Linux pode ser observadono desenvolvimento da biblioteca do GNU Emacs Lisp e os repositórios de código Lisp. Emcontraste com o estilo de desenvolvimento catedral do núcleo do Emacs C e a maioria dasoutras ferramentas da FSF, a evolução do grupo de código Lisp foi fluída e bastante dirigida aousuário. Idéias e protótipos foram freqüentemente re-escritos três ou quatro vezes antes deatingirem uma forma estável final. E colaborações permitidas pela Internet, a la Linux, foramfreqüentes.   Realmente,   minha   mais   bem   sucedida   codificação   anterior   ao   fetchmail   foiprovavelmente o modo Emacs VC, uma colaboração do tipo do Linux por email com trêsoutras pessoas, somente uma das eu conheci pessoalmente até hoje. Foi um front-end paraSCCS, RCS e posteriormente CVS pelo Emacs que oferecia operações de controle de versão"um toque''. Evoluiu de um pequeno e grosseiro modo sccs.el que alguém havia escrito. E odesenvolvimento do VC foi bem sucedido porque, ao contrário do próprio Emacs, o código doEmacs Lisp poderia ir por gerações de lançamento/teste/aperfeiçoamento muito rapidamente. 4. Libere cedo, libere freqüentementeLiberações novas e freqüentes são uma parte crítica do modelo de desenvolvimento do Linux.A maioria dos desenvolvedores (incluindo eu) costumava acreditar que esta era uma mápolítica para projetos maiores que os triviais, porque versões novas são quase por definiçãocheias de erros e você não quer acabar com a paciência dos seus usuários. Esta crençareforçou o compromisso de todos com o estilo de desenvolvimento catedral. Se o principalobjetivo  era  o de  usuários   verem  menos   erros   quanto   possível,   por que  então  você  iriasomente lançar um em cada seis meses (ou freqüentemente menos), e trabalhar como umcachorro depurando entre as liberações. O núcleo do Emacs C foi desenvolvido desta forma. Abiblioteca Lisp, de fato, não foi -- porque havia repositórios Lisp ativos fora do controle da FSF,aonde você poderia ir para achar versões novas e em desenvolvimento, independentementedo ciclo de liberação do Emacs. A mais importante destas, o repositório elisp do Estado deOhio, antecipou o espírito e muitas das características dos atuais grandes repositório de Linux.Mas pouco de nós realmente pensou muito sobre o que estávamos fazendo, ou sobre o que aexistência deste repositório sugeriu sobre problemas no modelo de desenvolvimento catedralda FSF.  Eu  fiz uma séria tentativa por volta de 1992 para ter  bastante código  de Ohioformalmente fundido na biblioteca oficial do Emacs Lisp. Encontrei problemas políticos e fuimuito mal sucedido. Mas um ano depois, visto que o Linux se tornou amplamente conhecido,ficou claro que alguma coisa diferente e muito saudável estava acontecendo. A política dedesenvolvimento aberta do Linus era exatamente o oposto do modelo de desenvolvimentocatedral. Os repositórios sunsite e tsx-11 estavam germinando, múltiplas distribuições estavamsurgindo. E tudo isto foi guiado por uma freqüência desconhecida de liberações de núcleo desistemas. Linus estava tratando seus usuários como co-desenvolvedores na maneira maiseficaz possível: 7. Liberece cedo. Libere freqüentemente. E ouça seus fregueses. Isso nãoera muito a inovação do Linus (algo como isso estava sendo a tradição do mundo Unix por umlongo tempo), mas em elevar isto até um grau de intensidade que alcançava a complexidadedo que ele estava desenvolvendo. Nestes primórdios tempos (por volta de 1991) não eraestranho para ele liberar um novo kernel mais de uma vez por dia! E, porque ele cultivava suabase de co-desenvolvedores e incitava fortemente a Internet por colaboração como nenhumoutro, isto funcionou. Mas como isto funcionou? E era isto algo que eu poderia duplicar, ou eraalgo   que   dependia   da   genialidade   única  de   Linus   Torvalds?   Eu   não   pensei   assim.Reconhecidamente, Linus é um excelente desenvolvedor (quantos de nós poderia planejar umkernel completo de um sistema operacional de qualidade de produção?). Mas o Linux nãorepresentou nenhum salto conceitual impressionante a frente. Linus não é (ou pelo menos,ainda não) um gênio inovativo de projeto do estilo que, por exemplo, Richard Stallman ouJames Gosling (do NeWS e Java) são. Ao contrário, para mim Linus parece ser um gênio daengenharia, com um sexto sentido em evitar erros e desenvolvimentos que levem a um becosem saída e uma verdadeira habilidade para achar o caminho do menor esforço do ponto A aoponto B.  De fato,  todo o projeto do Linux  exala esta qualidade e  espelha a  abordagemconservadora   e   simplificada   de   planejamento   do   Linus.   Então,   se   liberações   rápidas   einfluenciar a Internet a todo custo não foram acidentes mas partes integrantes da perspicáciado   gênio   de   engenharia   do   Linus   para   o   caminho  do   menor   esforço,   o   que   ele   estavaenfatizando? O que ele estava maquinando? Posto desta forma, a questão responde a si
mesma. Linus estava mantendo seus usuários/desenvolvedores constantemente estimuladose   recompensados   --   estimulados   pela   perspectiva   de   estar   tendo   um   pouco   de   açãosatisfatória do ego, recompensados pela visão do constante (até mesmo diário) melhoramentodo seu trabalho. Linus estava diretamente direcionado a maximizar o número de pessoas-horadedicadas a depuração e ao desenvolvimento, mesmo com o possível custo da instabilidadeno código e extinção da base de usuários se qualquer erro sério provasse ser intratável. Linusestava se comportando como se acreditasse em algo como isto: 8. Dada uma base grande osuficiente   de   beta-testers   e   co-desenvolvedores,   praticamente   todo   problema   serácaracterizado rapidamente e a solução será óbvia para alguém. Ou, menos formalmente,"Dados olhos suficientes, todos os erros são triviais.'' Eu chamo isso de: "Lei de Linus''. Minhaformulação original foi que todo problema "será transparente para alguém''. Linus objetou quea   pessoa   que   entende   e   conserta   o   problema   não   é   necessariamente   ou   mesmofreqüentemente a pessoa que primeiro o caracterizou. "Alguém acha o problema,'' ele diz, "euma outra pessoa o entende. E eu deixo registrado que achar isto é o grande desafio.'' Mas oponto é que ambas as coisas tendem a acontecer rapidamente. Aqui, eu penso, é o centro dadiferença fundamental entre os estilos bazar e catedral. Na visão catedral de programação,erros e problemas de desenvolvimento são difíceis, insidiosos, um fenômeno profundo. Levameses de exame minucioso por poucas pessoas dedicadas para desenvolver confiança de quevocê se livrou de todos eles. Por conseguinte os longos intervalos de liberação, e o inevitáveldesapontamento quando as liberações por tanto tempo esperadas não são perfeitas. Na visãobazar, por outro lado, você assume que erros são geralmente um fenômeno trivial -- ou, pelomenos, eles se tornam triviais muito rapidamente quando expostos para centenas de ávidosco-desenvolvedores   triturando   cada   nova   liberação.   Consequentemente   você   liberafreqüentemente para ter mais correções, e como um benéfico efeito colateral você tem menosa perder se um erro ocasional aparece. E é isto. É o suficiente. Se a "Lei de Linus'' é falsa,então qualquer sistema tão complexo como o kernel do Linux, sendo programado por tantasmãos quantas programam o kernel do Linux, deveria a um certo ponto tido um colapso sob opeso de interações imprevisíveis e erros "profundos'' não descobertos. Se isto é verdade, poroutro lado, é suficiente para explicar a relativa falta de erros do Linux. E talvez isso não deveriaser uma surpresa, mesmo assim. Anos atrás, sociologistas descobriram que a opinião médiade uma massa de observadores especialistas (ou igualmente ignorantes) é um indicador maisseguro que o de um único observador escolhido aleatoriamente. Eles chamaram isso de o"efeito Delphi''. Parece que o que o Linus tem mostrado é que isto se aplica até mesmo paradepurar um sistema operacional -- que o efeito Delphi pode suavizar a complexidade dodesenvolvimento até mesmo em nível de complexidade do kernel de um sistema operacional.Eu sou grato a Jeff Dutky por apontar que a lei de Linus pode ser refeita como "Depurar éparalelizável''. Jeff observa que embora depurar requer que depuradores se comuniquem comalgum desenvolvedor coordenador, não requer coordenação significante entre depuradores.Assim não cai vítima para a mesma complexidade quadrática e custos de gerência que faz serproblemático adicionar desenvolvedores. Na prática, a perda teórica de eficiência devido aduplicação de trabalho por depuradores quase nunca parece ser um problema no mundo doLinux.  Um efeito da  ``política  libere cedo e freqüentemente''  é minimizar esta duplicaçãopropagando   consertos   rapidamente.   Brooks   até   mesmo   fez   uma   observação   improvisadarelacionada à observação de Jeff: "O custo total de manter um programa amplamente utilizadoé tipicamente 40 porcento ou mais o custo de desenvolvê-lo. Surpreendentemente este custo émuito afetado pelo número de usuários. Mais usuários acham mais erros.'' (minha ênfase).Mais usuários acham  mais erros porque  adicionar mais  usuários adiciona mais maneirasdiferentes   de   testar   o   programa.   Este   efeito   é   amplificado   quando   os   usuários   são   co-desenvolvedores.   Cada   um   aborda   a  tarefa   de  caracterização   de  erro   com  um   conjuntoperceptivo ligeiramente diferente e ferramenta analítica, um ângulo diferente do problema. O"efeito   Delphi''   parece   funcionar   precisamente   por   causa   desta   variação.   No   contextoespecífico da depuração, a variação também tende a reduzir o feito da duplicação. Entãoadicionar mais beta-testers pode não reduzir a complexidade de um erro "profundo'' correntedo ponto  de  vista do desenvolvedor,  mas aumenta a  probabilidade  que a ferramenta dealguém irá de encontro ao problema de uma maneira tal que o problema será trivial para estapessoa. Linus cobre suas apostas. Caso haja erros sérios, as versões do kernel do Linux sãonumeradas de forma que usuários em potencial podem fazer a escolha de executar a últimaversão   designada   "estável''   ou   correr   o   risco   de   encontrar   erros   para   obter   novascaracterísticas.   Esta   técnica  não   é   ainda   formalmente   imitada   pela   maioria   dos
desenvolvedores usuários do Linux, mas talvez devesse; o fato de que ambas as escolhasestejam disponíveis faz delas mais atraentes. 5. Quando uma rosa não é uma rosa Tendo estudado o comportamento do Linus e formado uma teoria sobre como ele foi bemsucedido,   eu   fiz   uma   decisão   consciente   para   testar   esta   teoria   em   meu   novo(reconhecidamente muito menos complexo e ambicioso) projeto. Mas a primeira coisa que eufiz foi reorganizar e simplificar bastante o popclient. A implementação do Carl Harris era muitoatrativa, mas exibia um tipo de complexidade desnecessária comum a vários programadoresem C. Ele tratou o código como centro das atenções e as estruturas de dados como suportepara o código. Como resultado, o código era muito bonito mas o projeto da estrutura de dadosera ad-hoc e um tanto feio (pelo menos pelos altos padrões deste velho desenvolvedor deLISP). Eu tinha outro propósito para re-escrever além de aperfeiçoar o código e o projeto daestrutura de dados, entretanto. Era evoluí-lo para algo que eu entenderia completamente. Nãoé nada agradável ser responsável por consertar erros em um programa que você não entende.Mais   ou   menos   durante   o   primeiro   mês,   então,   eu   estava   simplesmente   seguindo   asimplicações do projeto básico do Carl. A primeira mudança séria que fiz foi adicionar suporteao IMAP. Eu fiz isso reorganizando as rotinas de protocolos em um driver genérico e trêstabelas de métodos (para POP2, POP3 e IMAP). Esta e as mudanças anteriores ilustram oprincípio geral que é bom para os programadores manterem em mente, especialmente emlinguagens como C que não implementam naturalmente tipagem dinâmica:  9. Estrutura dedados inteligentes e código burro trabalham muito melhor que ao contrário. Brooks,Capítulo 11: "Mostre-me seu código e esconda suas estruturas de dados, e eu podereicontinuar mistificado. Mostre-me suas estruturas de dados, e eu provavelmente nãonecessitarei do seu código;ele será óbvio.'' De fato, ele disse "gráficos'' e "tabelas''. Masconsiderando trinta anos de terminologias/mudanças culturais, é praticamente o mesmo ponto.Neste ponto (quase Setembro de 1996, mais ou menos seis semanas desde o início) eucomecei a pensar que uma mudança de nome deveria ser adequada -- afinal de contas, nãoera  mais  somente  um  cliente   POP.  Mas  eu  hesitei,   porque  ainda não  havia  ainda  nadagenuinamente novo ainda no projeto. Minha versão do popclient ainda teria que desenvolveruma identidade própria. Isto mudou, radicalmente, quando o fetchmail aprendeu como reenviarmensagens recebidas para a porta SMTP. Eu irei a este ponto em um momento. Mas primeiro:Eu disse acima que eu decidi usar este projeto para testar minha teoria sobre o que LinusTorvalds fez corretamente. Como (você pode perguntar) eu fiz isto? Desta forma: 1.Eu libereicedo e freqüentemente (quase nunca menos que uma vez a cada dez dias; durante períodosde desenvolvimento intenso, uma vez por dia). 2.Eu aumentei minha lista de beta testersadicionando a ela todo mundo que me contatava sobre o fetchmail. 3.Eu mandei extensosanúncios à lista de beta testers toda vez que eu liberava, encorajando as pessoas a participar.4.E   eu   ouvia   meus   beta   testers,   questionando-os   sobre   decisões   de   desenvolvimento   eincitando-os toda vez que eles mandavam consertos e respostas. O retorno destas medidassimples  foi  imediato.  Desde  o  início  do  projeto,  eu  obtive relatórios  sobre   erros   de umaqualidade que a maioria dos desenvolvedores morreria para ter, muitas vezes com ótimosconsertos incluídos. Eu obtive críticas severas, obtive mensagens de fãs, obtive sugestõesinteligentes de características. O que leva a: 10. Se você tratar seus beta testers como seurecurso mais valioso, eles irão responder tornando-se seu mais valioso recurso.  Umamedida interessante do sucesso do fetchmail é o simples tamanho da lista de beta testers,amigos do fetchmail. Ao escrever este texto ela possuía 249 membros e são adicionados doisou três por semana. De fato, conforme eu reviso ao final de Maio de 1997, a lista estácomeçando a perder membros depois do pico de aproximadamente 300 pessoas por umarazão interessante. Muitas pessoas têm me pedido para excluí-las da lista porque o fetchmailestá trabalhando tão bem para elas que elas não precisam mais ver o tráfego da lista! Talvezisto seja parte do ciclo de vida normal de um projeto maduro do estilo bazar. 6. Popclient transforma-se em Fetchmail O verdadeiro ponto de mudança no projeto foi quando Harry Hochheiser me mandou o seu
rascunho de código para reenviar mensagens para a porta SMTP da máquina cliente. Eupercebi quase imediatamente que uma implementação segura desta característica iria tornartodos   os   outros   modos   de   envio   perto   do   obsoleto.   Por   muitas   semanas   eu   fiqueicustomizando   o   fetchmail   de   maneira   incremental   enquanto   percebia   como  o   projeto   deinterface estava aproveitável mas feio -- não estava elegante e com muitas pequenas opçõespor toda parte. As opções para extrair mensagens coletadas para um arquivo de mensagensou saída padrão particularmente me aborreciam, mas eu não conseguia descobrir por que. Oque eu vi quando eu pensei sobre reenvio SMTP foi que o popclient estava tentando fazermuitas coisas. Ele foi projetado para ser tanto um agente transportador de correspondência(MTA) quanto um agente local de entrega (MDA). Com reenvio SMTP, ele poderia retirar oMDA e ser somente um MTA, transferindo as correspondências para outros programas paraentrega   local   como   o   sendmail   faz.   Por   que   se   envolver   com  toda   a   complexidade   deconfigurar um agente de entrega de correspondência ou configurar lock-e-append em umarquivo de correio quando a porta 25 é quase garantida para estar lá em primeiro lugar emqualquer plataforma com suporte para TCP/IP? Especialmente quando isso significa que ocorreio   coletado   é   garantido   parecer   como  um   correio   SMTP   iniciado   pelo   remetentenormalmente, o que, de qualquer maneira, é realmente o que queremos. Há várias lições aqui.Primeira, esta idéia de reenvio por SMTP foi o primeiro grande retorno que eu obtive por tentarconscientemente emular os métodos do Linus. Um usuário me deu esta idéia brilhante -- tudoque eu tive que fazer foi entender as implicações. 11. A melhor coisa depois de ter boasidéias é reconhecer boas idéias dos seus usuários. As vezes a última é melhor. E o que éinteressante, você irá rapidamente descobrir que se você está se achando completamentedesacreditado sobre o quanto você deve a outras pessoas, o mundo inteiro irá tratá-lo como sevocê mesmo tivesse criado cada bit da invenção e está somente sendo modesto sobre seugênio inato. Nós todos podemos ver o quanto isso funcionou para Linus! (Quando eu mostreieste documento na conferência de Perl em Agosto de 1997, Larry Wall estava na primeira fila.Quando eu li a última linha acima ele gritou fervorosamente, em um estilo religioso nostálgico,"Diga, diga, irmão!''. Toda a audiência riu, porque eles sabiam que isso também funcionou parao criador do Perl.) Após poucas semanas executando o projeto no mesmo espírito, eu comeceia ganhar um louvor semelhante não apenas dos meus usuários mas de outras pessoas quedeixaram as palavras escaparem. Eu guardei algumas destas mensagens; irei olhar para elasnovamente algum dia se eu começar a questionar se a minha vida valeu a pena :-). Mas háduas lições mais fundamentais aqui, não políticas, que são gerais para todos os tipos deprojeto. 12. Freqüentemente, as soluções mais impressionantes e inovadoras surgem aose perceber que o seu conceito do problema estava errado. Eu estava tentando resolver oproblema errado ao desenvolver continuamente o popclient como um MTA/MDA combinadocom todos os tipos de modos de distribuição local. O projeto do fetchmail precisava serrepensado do início como um puro MTA, uma parte do caminho normal do correio da Internetque fala SMTP. Quando você atinge uma parede ao desenvolver -- quando você dificilmentese encontra pensando em algo depois do próximo patch -- é freqüentemente tempo paraperguntar não se você tem a resposta certa, mas se você está perguntando a perguntacorreta.   Talvez   o   problema   precise   ser   reformulado.   Bem,   eu   reformulei   meu   problema.Claramente, a coisa certa a fazer era (1) codificar o suporte para reenvio por SMTP no drivergenérico, (2) tornar isto o modo default, e (3) eventualmente desfazer todos os outros modosde envio, especialmente as opções de enviar-para-arquivo e enviar-para-saída-padrão. Euhesitei sobre o passo 3 por algum tempo, temendo aborrecer os usuários de longa data dopopclient   dependentes   dos   mecanismos   alternativos   de   envio.   Em   teoria,   eles   poderiamimediatamente passar a usar arquivos .forward ou seus equivalentes não-sendmail para obteros mesmos efeitos. Na prática a transição poderia ser confusa. Mas quando eu a fiz, osbenefícios provaram-se altos. As partes obscuras do código do driver sumiram. A configuraçãoficou radicalmente mais simples -- não mais rastejar à volta atrás do MDA do sistema e dacaixa de correio do usuário, não mais preocupações sobre se o sistema operacional suportavalocking de arquivo. Além disso, a única maneira de perder correio sumira. Se você especificavaenvio para um arquivo e o disco estava cheio, seu correio estaria perdido. Isto não podeacontecer com o reenvio por SMTP porque o receptor SMTP não retornará OK a não ser que amensagem possa ser enviada ou pelo menos reprogramada para um envio mais tarde. Etambém,  a  performance  aumentou   (embora  você  não perceberia  isso  somente  com  umaexecução). Outro benefício não insignificante foi que a página do manual ficou muito maissimples. Mais tarde, eu tive que recolocar envio por um MDA local especificado pelo usuário
para permitir o tratamento de algumas situações obscuras envolvendo SLIP dinâmico. Mas euencontrei um_ maneira muito mais simples de fazer isto. A moral? Não hesite em jogar foracaracterísticas obsoletas quando você puder fazer isso sem perda de efetividade. Antoine deSaint-Exupéry (que foi um aviador e projetista de aviões quando ele não estava sendo o autorde livros clássicos infantis) disse: 13. "A perfeição (em projetar) é alcançada não quandonão há mais nada a adicionar, mas quando não há nada para jogar fora.'' Quando o seucódigo está ficando tão bom quanto simples, é quando você sabe que está correto. E noprocesso,   o   projeto   do   fetchmail   adquiriu   uma   identidade   própria,   diferente   do   ancestralpopclient. Era tempo para a mudança de nome. O novo projeto parecia muito mais como umirmão   do   sendmail   do  que   o   velho   popclient   parecia;   ambos   eram   MTAs,   mas   aonde  osendmail passa e então envia, o novo popclient coleta e então envia. Então, após 2 meses, eumudei o nome para fetchmail. 7. Fetchmail cresce Lá estava eu com um projeto elegante e inovador, um código que eu sabia que funcionavabem porque eu usava todos os dias, e uma crescente lista de beta testers. E gradualmente eupercebia que eu não estava mais ocupado com uma trivial codificação pessoal que porventurapoderia se tornar útil para algumas pessoas. Eu tinha em minhas mãos um programa quetodos os usuários de um sistema Unix com uma conexão de correio SLIP/PPP realmenteprecisavam.   Com   a   característica   de   reenvio   por   SMTP,   ele   passou   muito   à   frente   dacompetição para potencialmente se tornar um "category killer'', um destes programas clássicosque   preenchem   seu   nicho  tão   completamente   que   as   alternativas   não   são   somentedescartadas como também esquecidas. Eu penso que você não pode realmente almejar ouplanejar um resultado como este. Você tem que ser atraído para isso por idéias de projeto tãopoderosas   que   posteriormente   os   resultados   parecem   inevitáveis,   naturais,   mesmopredestinados. A única maneira de tentar idéias como esta é tendo muitas idéias -- ou tendo ojulgamento de engenharia para levar as boas idéias das outras pessoas além do que estasque as tiveram pensariam que elas poderiam ir. Andrew Tanenbaum teve a idéia original deconstruir um Unix nativo simples para o 386, para uso como uma ferramenta de ensino. LinusTorvalds levou o conceito do Minix para além do que Andrew provavelmente pensou quepoderia ir -- e cresceu para algo maravilhoso. Da mesma forma (embora em uma menorescala), eu peguei algumas idéias de Carl Harris e Harry Hochheiser e dei um empurrão.Nenhum de nós foi 'original' no sentido romântico que as pessoas pensam é um gênio. Mas amaioria do desenvolvimento de software científico e de engenharia não é feita por um gêniooriginal, a mitologia desenvolvedor ao contrário. Os resultados foram todos sempre muitoprecipitados   --   de   fato,   o   tipo   de   sucesso   que   qualquer   desenvolvedor   está   sempreprocurando! E eles significaram que eu teria que definir meus padrões ainda mais altos. Parafazer o fetchmail tão bom como eu então achava que poderia se tornar, eu teria que escrevernão   somente   para   minhas   próprias   necessidades,   mas   também   incluir   e   suportarcaracterísticas necessárias para outros fora do meu relacionamento. E fazer isto mantendo oprograma simples e robusto. A primeira e mais importante esmagadora característica que euescrevi depois de perceber isto foi o suporte a multidrop -- a habilidade de capturar correio decaixas de correio que acumularam todas as mensagens para um grupo de usuários, e entãodestinar cada pedaço de correio para seus destinatários individuais. Eu decidi adicionar osuporte   ao   multidrop   em   parte   porque   alguns   usuários   estavam   pedindo   por   isto,   masprincipalmente porque eu pensei que isto iria retirar os erros do código para o envio simplesme forçando a manipular o endereçamento de um modo geral. E assim se provou 822 metomou um tempo consideravelmente longo, não porque qualquer pedaço dele é difícil masporque envolvia uma pilha de detalhes interdependentes e elaborados. Mas o endereçamentomultidrop se tornou uma decisão de projeto excelente. Aqui está como eu soube: 14. Qualquerferramenta deve ser útil da maneira esperada, mas uma ferramenta verdadeiramente*boa*  leva  ela  própria   a usos que  você  nunca   esperou.  Outra   importante   mudançasolicitada pelos meus beta testers foi suporte para operação MIME 8-bit. Isto foi muito fácil defazer, porque eu estava sendo cuidadoso mantendo o código pronto para 8-bit. Não porque euantecipei a demanda para esta característica, mas em obediência a outra regra: 15. Quandoescrevendo um software gateway de qualquer tipo, faça tudo para perturbar o conjuntode dados o menos possível  -- e *nunca* jogue fora informação a não ser que o
destinatário force você a isto! Se eu não tivesse obedecido esta regra, o suporte a MIME 8-bit teria sido difícil e cheio de erros. Como estava, tudo o que tive 1652 e adicionar um poucode lógica trivial para a geração de cabeçalho. Alguns usuários Europeus insistiram para que euadicionasse uma opção para limitar o número de mensagens recebidas por seção (de maneiraque eles poderiam controlar custos das suas caras redes de telefone). Eu resisti por um longotempo, e ainda não estou inteiramente alegre sobre isto. Mas se você está escrevendo para omundo, você tem que ouvir os seus clientes -- isto não muda somente porque eles não estãopagando dinheiro a você. 8. Algumas lições a mais do Fetchmail Antes de voltarmos ao assunto de engenharia de software em geral, existem algumas lições amais da experiência do fetchmail para ponderar. A sintaxe do arquivo rc inclui palavra-chaves'ruidosas' opcionais que são inteiramente ignoradas pelo analisador. A sintaxe parecida com oInglês   que   elas   permitem   é   consideravelmente   mais   inteligível   que   os   concisos   parestradicionais palavra-chave-valor que você obtém quando as retira. Estas começaram como umexperimento   posterior   quando   eu   percebi   como  as   declarações   do   arquivo   rc   estavacomeçando a lembrar uma mini-linguagem imperativa. (É por isto também que eu mudei apalavra-chave original 'server' do popclient para 'poll'). Parecia para mim que tentar fazer estamini-linguagem imperativa parecer mais como o Inglês poderia torná-la mais fácil de ser usada.Agora, embora eu seja um convencido adepto da escola de projeto "faça isso uma linguagem''como  exemplificado   pelo   Emacs   e   HTML   e   muitos   sistemas   de   banco   de   dados,   eunormalmente não sou um grande fã das sintaxes "English-like''. Programadores tradicionaistendem a serem a favor de sintaxes de controle que são muito precisas e compactas e nãocontém redundância alguma. Isto é um legado cultural de quando os recursos computacionaiseram   caros,   então   os  estágios   de  análise   tinham   que   ser  tão   baratos   e   simples   quantopossíveis. O Inglês, com redundância de aproximadamente 50%, parecia ser um modelo muitoimpróprio. Esta não é minha razão para normalmente evitar sintaxes no estilo do Inglês; eumenciono isto aqui somente para arrasá-la. Com ciclos e núcleos baratos, concisão não deveser ela mesma um fim. Hoje em dia é mais importante para uma linguagem ser convenientepara humanos do que ser barata para o computador. Há, entretanto, boas razões para sercauteloso. Uma é o custo da complexidade do estágio de análise -- você não quer aumentá-loao ponto onde é uma fonte significativa de erros e confusão de usuários. Outra é que tentarfazer a sintaxe de uma linguagem English-like freqüentemente demanda que o "Inglês'' que éfalado seja seriamente propenso a ser fora de forma, tanto como a semelhança superficial coma linguagem natural é tão confusa como a sintaxe tradicional seria. (Você vê isso em váriaslinguagens chamadas de "quarta geração'' e em linguagens de consulta de banco de dadoscomerciais.)   A   sintaxe   de   controle   do   fetchmail   parece   evitar   estes   problemas   porque   odomínio da linguagem é extremamente restrito. Não é perto de uma linguagem de uso geral;as coisas que ela diz simplesmente não são muito complicadas, então há pouco potencial paraconfusão em mover mentalmente entre um pequeno conjunto do Inglês e a real linguagem decontrole. Eu acho que há uma lição mais abrangente aqui: 16. Quando sua linguagem nãoestá perto de um Turing completo, açúcar sintático pode ser seu amigo.  Outra lição ésobre segurança por obscuridade. Alguns usuários do fetchmail me pediram para mudar osoftware para guardar as senhas encriptadas no arquivo rc, de maneira que bisbilhoteiros nãopoderiam casualmente vê-las. Eu não fiz isso, porque isto não adiciona realmente proteção.Qualquer pessoa que adquira permissões para ler seu arquivo rc poderá executar o fetchmailcomo você de qualquer maneira -- e se é a sua senha o que eles procuram, poderiam retirar odecodificador do próprio fetchmail para consegui-la. Tudo o que a encriptação de senha doarquivo .fetchmailrc faria seria dar a falsa impressão de segurança para pessoas que nãopensaram bem sobre este assunto. Aqui a regra geral é: 17. Um sistema de segurança é tãoseguro quanto é secreto. Esteja atento a pseudo-segredos. 9. Pré-condições necessárias para o estilo Bazar Os primeiros leitores e audiências para este documento seguidamente levantaram questõessobre as pré-condições para o desenvolvimento bem-sucedido do estilo bazar, incluindo as
qualificações do líder do projeto e o estado do código ao tempo em que se torna público ecomeça a tentar construir uma comunidade de co-desenvolvedores. Está claro que ninguémpode codificar desde o início no estilo bazar. Alguém pode testar, achar erros e aperfeiçoar noestilo bazar, mas seria muito difícil originar um projeto no estilo bazar. Linus não tentou isto. Eutambém não. A sua comunidade nascente de desenvolvedores precisa ter algo executável epassível de testes para utilizar. Quando você começa a construção de uma comunidade, o quevocê precisa ter capacidade de apresentar é uma promessa plausível. Seu programa nãoprecisa funcionar particularmente bem. Ele pode ser grosseiro, cheio de erros, incompleto, epobremente documentado. O que não pode deixar de fazer é convencer co-desenvolvedoresem potencial de que ele pode evoluir para algo realmente elegante em um futuro próximo.Tanto o Linux quanto o fetchmail se tornaram públicos com projetos básicos fortes e atraentes.Muitas   pessoas   pensando   sobre   o   modelo   bazar   como   eu   tenho   apresentado   têmcorretamente considerado isto como crítico, então concluíram a partir disso que um alto graude intuição e inteligência no líder do projeto é indispensável. Mas Linus obteve seu plano doUnix. Eu obtive o meu inicialmente do ancestral do popclient (embora iria posteriormentemudar bastante,  muito  mais proporcionalmente falando  do  que  mudou  o Linux).  Então énecessário realmente para o líder/coordenador de um empenho no estilo bazar ter um talentoexcepcional para planejamento, ou ele pode conseguir o mesmo efeito coordenando o talentode planejamento de outras pessoas? Eu penso que não é crítico que o coordenador sejacapaz   de   originar   projetos   de   excepcional   brilho,   mas   é   absolutamente   crítico   que   ocoordenador seja capaz de reconhecer boas idéias de projetos de outras pessoas. Tanto osprojetos do Linux quanto o do fetchmail mostram evidências disso. Linus, não sendo (comopreviamente   discutido)   um   planejador   espetacularmente   original,   mostrou   uma   habilidadepoderosa de reconhecer um bom projeto e integrá-lo no kernel do Linux. E eu já descrevi comoa idéia de projeto mais poderosa do fetchmail (reenvio por SMTP) veio de outra pessoa. Osprimeiros leitores deste documento me elogiaram sugerindo que eu sou propenso a subestimara originalidade do planejamento de projetos no estilo bazar porque eu tenho muito disso emmim mesmo, e portanto suponho isto. Pode haver alguma verdade nisto; projetar (como opostoa codificar ou depurar) é certamente minha mais forte habilidade. Mas o problema em serinteligente e original no planejamento de software é que isto se torna um hábito -- vocêcomeça reflexivamente a fazer coisas atraentes e complicadas quando você deveria mantê-lasrobustas   e   simples.   Eu   tive   projetos   que   falharam   porque   eu   cometi   este   erro,   mas   euadministrei para que não acontecesse o mesmo com o fetchmail. Então eu acredito que oprojeto do fetchmail foi um sucesso em parte porque eu impedi a minha tendência a serengenhoso;   isto   vai   contra   (pelo   menos)   com   o   fato   de   a   originalidade   em   projetar   seressencial para projetos bem-sucedidos no estilo bazar. E considere o Linux. Suponha queLinus Torvalds estivesse tentando levar a cabo inovações fundamentais no projeto de sistemasoperacionais durante o desenvolvimento; pareceria que o kernel resultante seria tão estável ebem-sucedido como é? Um certo nível básico de habilidade de projetar e codificar é requerido,claro, mas eu suponho que praticamente qualquer um que pense seriamente em lançar umesforço no estilo bazar estará acima do mínimo necessário. O mercado interno da comunidadede software aberto, por reputação, exerce uma sutil pressão nas pessoas para que não lancemesforço de desenvolvimento que não sejam competentes para manter. Até agora isto pareceter funcionado muito bem. Há outro tipo de habilidade que não é normalmente associada como desenvolvimento de software que eu penso é tão importante quanto a engenhosidade emplanejar projetos no estilo bazar -- e isto pode ser mais importante. Um coordenador ou líderde um projeto no estilo bazar deve ter boa habilidade de comunicação e relacionamento. Istodeve parecer óbvio. Para construir uma comunidade de desenvolvimento, você precisa atrairpessoas, fazer com que se interessem no que você está fazendo, e mantê-las alegres sobre aquantidade de trabalho que estão fazendo. O entusiasmo técnico constitui uma boa parte paraatingir isto, mas está longe de ser toda história. A personalidade que você projeta tambémimporta. Não é uma coincidência que Linus é um rapaz gentil que faz com que as pessoasgostem dele e que o ajudem. Não é uma coincidência que eu seja um enérgico extrovertidoque gosta de trabalhar com pessoas e tenha um pouco de porte e instinto de um cômico. Parafazer o modelo bazar funcionar, isto ajuda enormemente se você tem pelo menos um pouco dehabilidade para encantar as pessoas. 10. O contexto social do código aberto
Está escrito: os melhores programas começam como soluções pessoais para os problemasdiários do autor, e se espalham porque o problema se torna típico para uma grande classe deusuários. Isto nos traz novamente para a regra 1, recolocada talvez de uma maneira mais útil:18. Para resolver um problema interessante, comece achando um problema que éinteressante para você. Isso foi o que aconteceu com Carl Harris e o ancestral popclient, etambém   comigo   e   o   fetchmail.   Mas   isso   foi   entendido   por   um   longo   tempo.   O   pontointeressante, o ponto que as histórias do Linux e do fetchmail parecem demandar o nossofoco, é o próximo estágio -- a evolução do software na presença de uma comunidade grande eativa de co-desenvolvedores. Em "The Mythical Man-Month'', Fred Brooks observou que otempo  de um programador não  é  acumulativo; adicionar desenvolvedores  em um projetoatrasado de software faz com que ele se torne mais atrasado. Ele expôs que a complexidade ecustos   de   comunicação   de   um   projeto   crescem   com  o   quadrado   do   número   dedesenvolvedores, enquanto o trabalho feito cresce somente linearmente. Esta afirmação édesde então conhecida como "A Lei de Brooks'' e é largamente considerada como correta.Mas se a Lei de Brooks fosse tudo a ser levado em consideração, o Linux seria impossível. Oclássico "The Psychology Of Computer Programming'', de Gerald Weinberg, sustentou o que,em   retrospectiva,   nós   podemos  ver   como   uma   correção   essencial   ao   Brooks.   Em   suadiscussão   sobre   "programação   sem   ego'',   Weinberg   observou   que   nos   lugares   ondedesenvolvedores não são territoriais sobre seu código, e encorajam outras pessoas a procurarpor erros e melhorias potenciais nele, as melhorias acontecem dramaticamente mais rápidasque em qualquer outro lugar. A escolha da terminologia de Weinberg talvez tenha prevenidosua análise de ganhar a aceitação que merecia -- é engraçado pensar em descrever osdesenvolvedores da Internet como "sem ego''. Mas acho que seu argumento parece mais maisconvincente hoje do que nunca. A história do Unix deveria ter sido preparada para nós do quenós estamos aprendendo com o Linux (e o que eu tenho verificado experimentalmente emuma menor escala por copiar deliberadamente os métodos do Linus). Isto é, embora codificarpermaneça uma atividade essencialmente solitária, os hacks realmente bons advém de captara atenção e poder de mente de comunidades inteiras. O desenvolvedor que utiliza apenas acapacidade cerebral dele mesmo em um projeto fechado irá ficar atrás de desenvolvedoresque saibam como criar um contexto aberto e evolutivo no qual a visualização de erros emelhorias sejam feitas por centenas de pessoas. Mas o mundo tradicional do Unix foi impedidode seguir completamente este método por vários fatores. Alguns deles foram os aspectoslegais de várias licenças, segredos de comércio e interesses comerciais. Outro (tardio) foi quea Internet ainda não estava boa o suficiente. Antes de a Internet baratear, havia algumascomunidades   geograficamente   pequenas   aonde   a   cultura   motivava   a   programação   "semego"???   de   Weinberg,   e   aonde   um   desenvolvedor   poderia   facilmente   atrair   muitos   co-desenvolvedores habilidosos. Bell Labs, o MIT AI Lab, UC Berkeley -- estes se tornaram aorigem de inovações que são lendárias e ainda fortes. Linux foi o primeiro projeto a fazer umesforço consciente e bem-sucedido a utilizar o mundo inteiro como sua reserva de talentos. Eunão acho que seja uma coincidência que o período de gestação do Linux tenha coincidido como nascimento da World Wide Web, e que o Linux tenha deixado a sua infância durante omesmo período em 1993-1994 que viu a expansão da indústria de ISP e a explosão doprincipal interesse da Internet. Linus foi a primeira pessoa que aprendeu como jogar com asnovas regras que a onipresente Internet fez possível. Embora uma Internet barata fosse umacondição  necessária para  que  o modelo  do Linux  evoluísse,   eu  penso  que  não  foi  umacondição por si só suficiente. Outro fator vital foi o desenvolvimento de um estilo de liderança econjunto   de   formalidades   cooperativas   que   permitiria   aos   desenvolvedores   atrair   co-desenvolvedores e obter o máximo suporte do ambiente. Mas o que é este estilo de liderançae estas formalidades? Eles não podem estar baseados em relações de poder -- e mesmo quepudessem, a liderança por coerção não produziria os resultados que nós vemos. Weinberg citaa autobiografia do anarquista do século 19 chamado Pyotr Alexeyvich Kropotkin, "Memórias deum Revolucionista'' para demonstrar o efeito neste assunto: "Tendo sido criado em uma famíliapossuidora de vassalos, eu entrei a vida ativa, como todos os jovens homens da minha idade,com uma grande confidência na necessidade de comandar, ordenar, repreender, punir e etc.Mas quando cedo tive que conduzir empreendimentos sérios e lidar com homens [livres], equando cada erro levaria de uma  vez a sérias conseqüências,  eu  comecei a apreciar adiferença entre atuar segundo o princípio de comando e disciplina e atuar segundo o princípioda compreensão comum. O primeiro funciona de forma admirável em uma parada militar, mas
de nada vale aonde a vida real é considerada, e o objetivo pode ser atingido somente peloesforço severo de muitos propósitos convergentes.'' O "esforço severo de muitos propósitosconvergentes'' é precisamente o que um projeto como o Linux requer -- e o "princípio decomando'' é efetivamente impossível de ser aplicado entre voluntários no paraíso anarquistaque nós chamamos de Internet. Para operar e competir efetivamente, desenvolvedores quequerem   liderar   projetos   colaborativos   têm   que   aprender   como   recrutar   e   energizarcomunidades   eficazes   com   interesse   no   modo   vagamente   sugerido   pelo   "princípio   decompreensão'' sugerido por Kropotkin. Eles precisam aprender a Lei de Linus. Inicialmente eume   referi   ao  "Efeito   Delphi''   como  uma   possível   explicação   para   a  Lei   de  Linus.   Porémanalogias  mais  poderosas   aos  sistemas   adaptativos  em  biologia  e  economia  também   seimplicam fortemente. O mundo do Linux se comporta em vários aspectos como um mercadolivre   ou   uma   ecologia,   uma   coleção   de   agentes   autônomos   tentando   maximizar   umempreendimento   que   no   processo   produz   uma   ordem   espontânea   auto-evolutiva   maiselaborada e eficiente que qualquer quantidade de planejamento central poderia ter alcançado.Aqui, então, é o lugar para procurar o "princípio da compreensão''. A "função empreendedora''que os desenvolvedores do Linux estão maximizando não é economia clássica, mas é aintangível satisfação do seu próprio ego e reputação entre outros desenvolvedores. (Alguémpode chamar a sua motivação de "altruísta'', mas isso ignora o fato que altruísmo é em simesmo uma forma de satisfação do ego para um altruísta). Culturas voluntárias que trabalhamdesta maneira não são realmente incomuns; uma outra que eu tenho participado há tempos éos fãs de ficção científica, que ao contrário dos desenvolvedores, explicitamente reconhecem o"egoboo'' (o aumento da reputação de alguém entre os outros fãs) como o guia básico por trásda atividade voluntária. Linus, por posicionar ele mesmo como o guia de um projeto em que odesenvolvimento é praticamente feito por outros, e por inspirar interesse no projeto até que elese   tornasse   auto-sustentável,   tem   mostrado   um   intenso   entendimento   do   "princípio   dacompreensão comum'' de Kropotkin. Esta visão quase-econômica do mundo do Linux nospermite ver como esta compreensão é aplicada. Nós podemos ver o método do Linus comouma   maneira   de   criar   um   mercado   eficiente   no   "egoboo''   --   para   ligar   a   autonomia   dedesenvolvedores   individuais   tão   firme   quanto   possível   para   dificultar   fins   que   podem   sersomente atingidos por uma cooperação sustentada. Com o projeto do fetchmail eu tenhomostrado (embora em uma menor escala) que seus métodos podem ser duplicados com bonsresultados. Talvez eu tenha até mesmo feito de uma maneira um pouco mais consciente esistemática   do   que   ele.   Muitas   pessoas   (especialmente   aquelas   que   politicamentedesacreditam   os   mercados   livres)   poderiam   esperar   de   uma   cultura   de   egoístas   auto-direcionadores   ser   fragmentada,   territorial,   desperdiçadora,   reservada   e   hostil.   Mas   estaexpectativa é claramente desfeita pela (para dar só um exemplo) imensa variedade, qualidadee profundidade da documentação do Linux. É notoriamente conhecido que os programadoresdetestam   documentar;   como,   então,   os   desenvolvedores   do   Linux   geram   tanto   disto?Evidentemente   o   mercado   livre   do   Linux   em   egoboo   trabalha   melhor   para   produzircomportamentos   virtuosos   e   direcionados   a   outros   propósitos   que   os   centros   dedocumentação massivamente fundados de produtores de software comercial. Tanto o projetodo fetchmail como o do kernel do Linux mostram que ao se recompensar propriamente o egode muitos outros desenvolvedores, um desenvolvedor/coordenador forte pode usar a Internetpara capturar os benefícios de se ter vários co-desenvolvedores sem fazer o projeto colapsarem uma confusão caótica. Então eu contra-proponho para a Lei de Brooks o seguinte:  19.Contanto que o coordenador do desenvolvimento tenha uma mídia pelo menos tão boaquanto   a   Internet,   e   saiba   como   liderar   sem   coerção,   muitas   cabeças   sãoinevitavelmente melhores que uma. Eu acredito que o futuro do software de código abertoirá pertencer gradativamente a pessoas que saibam como jogar o jogo do Linus, pessoas quedeixam para trás a catedral e abraçam o bazar. Isto não quer dizer que uma visão individual ebrilhante não irá mais ter importância; ao contrário, eu acredito que o estado da arte dosoftware de código aberto irá pertencer a pessoas que iniciem de uma visão individual ebrilhante, então amplificando-a através da construção efetiva de uma comunidade voluntáriade   interesse.   E   talvez   não   somente   o   futuro   do   software   de   código   aberto.   Nenhumdesenvolvedor de código fechado pode competir com o conjunto de talento que a comunidadedo Linux pode dar para resolver um problema. Muito poucos podem até mesmo ser capazesde pagar as mais de duzentas pessoas que têm contribuído para o fetchmail! Talvez no final acultura de código aberto irá triunfar não porque a cooperação é moralmente correta ou a"proteção'' do software é moralmente errada (assumindo que você acredita na última, o que
não faz tanto o Linus como eu), mas simplesmente porque o mundo do software de códigofechado não pode vencer uma corrida evolucionária com as comunidades de código abertoque podem colocar mais tempo hábil ordens de magnitude acima em um problema. 11. Agradecimentos Este documento foi enriquecido através de conversas com um grande número de pessoas queajudaram a depurá-lo. Agradecimentos particulares a Jeff Dutky , que sugeriu a formulação"depuração é paralelizável'', e ajudou a desenvolver a análise que se procedeu a isso. Etambém a Nancy Lebovitz pela sua sugestão que eu imitei Weinberg ao citar  Kropotkin.Críticas incisivas também vieram de Joan Eslinger e Marty Franz da lista de Técnicas Gerais.Sou grato aos membros do PLUG, o Grupo de Usuários de Linux da Filadélfia, por permitir aprimeira audiência de teste para a primeira versão pública deste documento. Finalmente, oscomentários   de   Linus   Torvalds   foram   importantes   e   seu   apoio   desde   o   início   foi   muitoestimulante. 12. Para leitura adicional Eu citei várias frases do clássico The Mythical Man-Month de Frederick P. Brook porque, emmuitos aspectos, suas considerações ainda precisam ser mais analisadas. Eu recomendofortemente   a   25a.   edição   de   Aniversário   de   Addison-Wesley   (ISBN   0-201-83595-9),   queadiciona seu documento "No Silver Bullet'' de 1986. A nova edição é envolvida por umainestimável retrospectiva de 20 anos atrasada na qual Brooks admite francamente os poucosjulgamentos no texto original que não resistiram ao teste do tempo. Achei que a retrospectivadeste   documento   estava   substancialmente   completa,   e   fiquei   surpreso   ao   descobrir   queBrooks atribui práticas como o estilo bazar à Microsoft! (De fato, entretanto, esta atribuiçãoHalloween que a comunidade interna de desenvolvimento da Microsoft é estratificada, com otipo comum de acesso ao código necessário para suportar o bazar muitas vezes nem mesmopossível.) The Psychology Of Computer Programming, de Gerald M. Weinberg (New York, VanNostrand Reinhold 1971) introduziu o conceito um tanto mal nomeado de "programação semego''. Embora ele não estivesse nem perto de ser a primeira pessoa a perceber a futilidade do"princípio do comando'', ele foi provavelmente o primeiro a reconhecer e argumentar o pontoparticular de ligação com o desenvolvimento de software. Richard P. Gabriel, contemplando acultura Unix da era pré-Linux, relutantemente argumentou a favor da superioridade do modeloprimitivo do estilo bazar em seu documento Lisp: Good News, Bad News, and How To Win Big,de 1989. Embora obsoleto em alguns aspectos, este ensaio ainda é muito cotado entre os fãsdo Lisp (incluindo eu). Um correspondente me lembrou que a seção entitulada "O Pior é oMelhor''   parece-se   mais   como   uma   antecipação   do   Peopleware:   Productive   Projects   andTeams (New York; Dorset House, 1987; ISBN 0-932633-05-6), de De Marco e Lister, é umajóia pouco apreciada na qual fiquei deliciado em ver Fred Brooks citá-la em sua retrospectiva.Embora pouco do que os autores têm a dizer é diretamente aplicável às comunidades docódigo aberto do Linux, as idéias do autor sobre as condições necessárias para um trabalhocriativo é incisivo e válido para qualquer um que tente importar um pouco das virtudes domodelo bazar para o contexto comercial. Finalmente, eu devo admitir que eu quase chameieste documento de "A Catedral e a Ágora'', o último termo sendo o grego para um mercadoaberto ou um lugar de encontro público. Os documentos "sistemas agóricos'' de Mark Miller eEric   Drexler,   descrevendo   as   propriedades   emergentes   de   ecologias   computacionais   demercado, me ajudaram a me preparar a pensar claramente sobre fenômenos análogos nacultura do código aberto quando o Linux esfregou o meu nariz neles cinco anos 13. Epílogo: Netscape acata o Bazar! É um sentimento estranho perceber que você está ajudando a fazer história? Em 22 deJaneiro de 1998, aproximadamente sete meses depois que eu publiquei pela primeira vez estedocumento,   Netscape   Communications,   Inc.   anunciou   o   código   aberto   do   NetscapeCommunicator.
14. Versão e Histórico de Mudanças$Id: cathedral-bazaar.sgml,v 1.42 1998/11/22 04:01:20 esr Exp $Eu liberei a versão 1.16 no Linux Kongress, em 21 de Maio de 1997.Eu adicionei a bibliografia em 7 de Julho de 1997 na versão 1.20.Eu adicionei a anedota da Perl Conference em 18 de Novembro de 1997 na versão 1.27.Eu mudei de ``software livre'' para ``código aberto'' em 9 de fevereiro de 1998 na versão 1.29.Eu adicionei ``Epílogo: Netscape Acata o Bazar!'' em 10 de Fevereiro de 1998 na versão 1.31.Eu  removi   o  gráfico   de  Paul   Eggert   sobre   GPL   vs.   bazar   em  resposta   aos   argumentoscoerentes de RMS em 28 de Julho de 1998.Eu   adicionei   uma   correção   de   Brooks   baseado   nos   Documentos   Halloween   em   20   deNovembro de 1998 na versão 1.40.Outros níveis de revisões incorporaram pequenas correçõ